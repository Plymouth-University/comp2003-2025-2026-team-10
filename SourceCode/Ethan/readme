# Procedural Wave Generation Pipeline (CFD → ParaView → Python → Unity)

## Overview

This workflow demonstrates how CFD wave data from an OpenFOAM simulation can be converted into a lightweight, procedurally generated ocean surface in Unity.
The goal is to **avoid storing large CFD datasets** while preserving realistic wave behaviour by extracting wave characteristics and regenerating them mathematically at runtime.

The pipeline consists of three stages:

1. Extract free-surface motion from CFD data using ParaView
2. Process the extracted data in Python to derive wave parameters
3. Use those parameters in Unity to generate waves procedurally (Gerstner waves)

Two Python scripts are provided:

* One for **testing and Unity integration** using synthetic wave parameters
* One for **deriving wave parameters from ParaView-exported CFD data**

---

## Stage 1: Extracting Free-Surface Motion in ParaView

### Purpose

OpenFOAM stores two-phase flow using the field `alpha.water`, which represents the water volume fraction.
The water–air interface (free surface) is commonly approximated by the isosurface where:

```
alpha.water = 0.5
```

ParaView is used to extract this interface and sample its vertical motion over time at a fixed horizontal location.

---

### Step-by-Step (ParaView)

#### 1. Load the OpenFOAM case

* File → Open → select the OpenFOAM case file (usually `case.foam`)
* Click **Apply**

#### 2. Enable the alpha.water field

* Select the OpenFOAM reader in the Pipeline Browser
* In Properties, enable the field `alpha.water`
* Click **Apply**

#### 3. Extract the free surface (interface)

* With the reader selected: **Filters → Contour**
* Set:

  * Contour By: `alpha.water`
  * Isosurfaces: `0.5`
* Click **Apply**

This creates a surface mesh representing the water–air interface at each timestep.

#### 4. Sample surface height using a vertical line

* Select the **Contour** output
* Filters → Data Analysis → **Plot Over Line**
* Define a vertical line at a fixed horizontal location:

  * Point1 = `(x, y_low, z)`
  * Point2 = `(x, y_high, z)`
* Choose `y_low` below the lowest water level and `y_high` above the highest.
* Click **Apply**

This samples the interface along a vertical line at the chosen `(x, z)` position.

#### 5. Convert the line samples into a time series

* Select the **PlotOverLine** output
* Filters → Temporal → **Plot Data Over Time**
* Click **Apply**

This produces line-sample values for every timestep.

#### 6. Save the data to CSV

* Select the **Plot Data Over Time** output
* File → Save Data
* Choose **CSV (*.csv)**
* Ensure “Write Time Steps” is enabled
* Save as:

```
paraview_line_over_time.csv
```

---

### Result of ParaView Stage

You now have a CSV file containing:

* Multiple rows per timestep (one per sampled point along the vertical line)
* Time values
* Point coordinates (including Y values)

This CSV represents the free-surface elevation over time and is the input to the Python processing stage.

---

## Stage 2: Python Processing Scripts

### Script 1: `gerstner_wave_generation_testing.py`

**Purpose**

* Generate plausible Gerstner wave parameters without CFD input
* Test the Unity pipeline (JSON loading + procedural wave rendering)

**What it does**

* Randomly generates multiple wave components:

  * Direction
  * Amplitude
  * Wavelength
  * Phase
  * Speed
  * Steepness
* Exports these parameters to a Unity-friendly JSON file

**Why it exists**

* Allows Unity implementation to be developed and validated independently of CFD data
* Provides a clean reference for how Gerstner parameters are structured

**Output**

```
waves_testing.json
```

This file is loaded directly by Unity and used to generate waves at runtime.

---

### Script 2: `gerstner_waves_from_paraview_csv.py`

**Purpose**

* Derive Gerstner wave parameters from CFD-derived free-surface motion
* Provide evidence that wave parameters can be extracted from simulation data

**Input**

```
paraview_line_over_time.csv
```

**What it does**

1. Groups CSV rows by timestep
2. Extracts the free-surface height η(t) for each timestep

   * Uses the median Y coordinate of contour intersection points
3. Computes wave characteristics:

   * Amplitude from peak-to-peak height
   * Dominant frequency via FFT
   * Angular frequency ω = 2πf
4. Constructs Gerstner wave parameters
5. Exports them to a Unity-compatible JSON file

**Important clarification**

* OpenFOAM fields named `k` and `omega` are turbulence-model variables
* In this script:

  * `k = 2π / L` (wave number)
  * `omega = 2πf` (wave angular frequency)

**Output**

```
waves_from_paraview.json
```

This JSON can be loaded directly by Unity to recreate CFD-derived wave behaviour procedurally.

---

## Stage 3: Unity Usage (High-Level)

Unity:

* Loads the exported JSON file once at startup
* Stores wave parameters in arrays or shader constants
* Every frame computes wave displacement using the Gerstner equations

At runtime:

* No CFD data is loaded
* No large files are required
* Waves are generated analytically with minimal performance cost

---

## Summary

* ParaView extracts free-surface motion from `alpha.water`
* Python converts that motion into compact wave parameters
* Unity regenerates the waves procedurally in real time
* File size and hardware requirements are reduced by orders of magnitude
* The approach is standard in real-time graphics and suitable for CFD visualisation contexts
